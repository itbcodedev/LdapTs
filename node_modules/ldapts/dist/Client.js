"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const url_1 = require("url");
const net = __importStar(require("net"));
const tls = __importStar(require("tls"));
const Attribute_1 = require("./Attribute");
const MessageParser_1 = require("./MessageParser");
const MessageResponseStatus_1 = require("./MessageResponseStatus");
const StatusCodeParser_1 = require("./StatusCodeParser");
const PagedResultsControl_1 = require("./controls/PagedResultsControl");
const messages_1 = require("./messages");
const MAX_MESSAGE_ID = Math.pow(2, 31) - 1;
const logDebug = debug_1.default('ldapts');
class Client {
    constructor(options) {
        this.messageId = 1;
        this.connected = false;
        this.messageParser = new MessageParser_1.MessageParser();
        this.messageDetailsByMessageId = {};
        this.clientOptions = options || {};
        if (!this.clientOptions.timeout) {
            this.clientOptions.timeout = 0;
        }
        if (!this.clientOptions.connectTimeout) {
            this.clientOptions.connectTimeout = 0;
        }
        this.clientOptions.strictDN = this.clientOptions.strictDN !== false;
        const parsedUrl = url_1.parse(options.url);
        if (!parsedUrl.protocol || !(parsedUrl.protocol === 'ldap:' || parsedUrl.protocol === 'ldaps:')) {
            throw new Error(`${options.url} is an invalid LDAP URL (protocol)`);
        }
        this.secure = parsedUrl.protocol === 'ldaps:';
        this.host = parsedUrl.hostname || 'localhost';
        if (parsedUrl.port) {
            this.port = Number(parsedUrl.port);
        }
        else if (this.secure) {
            this.port = 636;
        }
        else {
            this.port = 389;
        }
        this.messageParser.on('error', (err) => {
            if (err.messageDetails && err.messageDetails.messageId) {
                const messageDetails = this.messageDetailsByMessageId[err.messageDetails.messageId.toString()];
                if (messageDetails) {
                    delete this.messageDetailsByMessageId[err.messageDetails.messageId.toString()];
                    return messageDetails.reject(err);
                }
            }
            logDebug(err.stack);
        });
        this.messageParser.on('message', this._handleSendResponse.bind(this));
    }
    /**
     * Performs a simple authentication against the server.
     * @param {string} dn
     * @param {string} [password]
     * @param {Control|Control[]} [controls]
     */
    async bind(dn, password, controls) {
        if (!this.connected) {
            await this._connect();
        }
        if (controls && !Array.isArray(controls)) {
            // tslint:disable-next-line:no-parameter-reassignment
            controls = [controls];
        }
        const req = new messages_1.BindRequest({
            messageId: this._nextMessageId(),
            dn,
            password,
            controls,
        });
        const result = await this._send(req);
        if (result.status !== MessageResponseStatus_1.MessageResponseStatus.Success) {
            throw StatusCodeParser_1.StatusCodeParser.parse(result.status);
        }
    }
    /**
     * Used to create a new entry in the directory
     * @param {string} dn - DN of the entry to add
     * @param {Attribute[]|Object} attributes - Array of attributes or object where keys are the name of each attribute
     * @param {Control|Control[]} [controls]
     */
    async add(dn, attributes, controls) {
        if (!this.connected) {
            await this._connect();
        }
        if (controls && !Array.isArray(controls)) {
            // tslint:disable-next-line:no-parameter-reassignment
            controls = [controls];
        }
        let attributesToAdd;
        if (Array.isArray(attributes)) {
            attributesToAdd = attributes;
        }
        else {
            attributesToAdd = [];
            for (const [key, value] of Object.entries(attributes)) {
                let values;
                if (Array.isArray(value)) {
                    values = value;
                }
                else {
                    values = [value];
                }
                attributesToAdd.push(new Attribute_1.Attribute({
                    type: key,
                    values,
                }));
            }
        }
        const req = new messages_1.AddRequest({
            messageId: this._nextMessageId(),
            dn,
            attributes: attributesToAdd,
            controls,
        });
        const result = await this._send(req);
        if (result.status !== MessageResponseStatus_1.MessageResponseStatus.Success) {
            throw StatusCodeParser_1.StatusCodeParser.parse(result.status);
        }
    }
    /**
     * Compares an attribute/value pair with an entry on the LDAP server.
     * @param {string} dn - The DN of the entry to compare attributes with
     * @param {string} attribute
     * @param {string} value
     * @param {Control|Control[]} [controls]
     */
    async compare(dn, attribute, value, controls) {
        if (!this.connected) {
            await this._connect();
        }
        if (controls && !Array.isArray(controls)) {
            // tslint:disable-next-line:no-parameter-reassignment
            controls = [controls];
        }
        const req = new messages_1.CompareRequest({
            messageId: this._nextMessageId(),
            dn,
            attribute,
            value,
            controls,
        });
        const response = await this._send(req);
        switch (response.status) {
            case messages_1.CompareResult.compareTrue:
                return true;
            case messages_1.CompareResult.compareFalse:
                return false;
            default:
                throw StatusCodeParser_1.StatusCodeParser.parse(response.status);
        }
    }
    /**
     * Deletes an entry from the LDAP server.
     * @param {string} dn - The DN of the entry to delete
     * @param {Control|Control[]} [controls]
     */
    async del(dn, controls) {
        if (!this.connected) {
            await this._connect();
        }
        if (controls && !Array.isArray(controls)) {
            // tslint:disable-next-line:no-parameter-reassignment
            controls = [controls];
        }
        const req = new messages_1.DeleteRequest({
            messageId: this._nextMessageId(),
            dn,
            controls,
        });
        const result = await this._send(req);
        if (result.status !== MessageResponseStatus_1.MessageResponseStatus.Success) {
            throw StatusCodeParser_1.StatusCodeParser.parse(result.status);
        }
    }
    /**
     * Performs an extended operation on the LDAP server.
     * @param {string} oid - The object identifier (OID) of the extended operation to perform
     * @param {string} [value]
     * @param {Control|Control[]} [controls]
     */
    async exop(oid, value, controls) {
        if (!this.connected) {
            await this._connect();
        }
        if (controls && !Array.isArray(controls)) {
            // tslint:disable-next-line:no-parameter-reassignment
            controls = [controls];
        }
        const req = new messages_1.ExtendedRequest({
            messageId: this._nextMessageId(),
            oid,
            value,
            controls,
        });
        const result = await this._send(req);
        if (result.status !== MessageResponseStatus_1.MessageResponseStatus.Success) {
            throw StatusCodeParser_1.StatusCodeParser.parse(result.status);
        }
        return {
            oid: result.oid,
            value: result.value,
        };
    }
    /**
     * Performs an LDAP modify against the server.
     * @param {string} dn - The DN of the entry to modify
     * @param {Change|Change[]} changes
     * @param {Control|Control[]} [controls]
     */
    async modify(dn, changes, controls) {
        if (!this.connected) {
            await this._connect();
        }
        if (changes && !Array.isArray(changes)) {
            // tslint:disable-next-line:no-parameter-reassignment
            changes = [changes];
        }
        if (controls && !Array.isArray(controls)) {
            // tslint:disable-next-line:no-parameter-reassignment
            controls = [controls];
        }
        const req = new messages_1.ModifyRequest({
            messageId: this._nextMessageId(),
            dn,
            changes,
            controls,
        });
        const result = await this._send(req);
        if (result.status !== MessageResponseStatus_1.MessageResponseStatus.Success) {
            throw StatusCodeParser_1.StatusCodeParser.parse(result.status);
        }
    }
    /**
     * Performs an LDAP modifyDN against the server.
     * @param {string} dn - The DN of the entry to modify
     * @param {string} newDN - The new DN to move this entry to
     * @param {Control|Control[]} [controls]
     */
    async modifyDN(dn, newDN, controls) {
        if (!this.connected) {
            await this._connect();
        }
        if (controls && !Array.isArray(controls)) {
            // tslint:disable-next-line:no-parameter-reassignment
            controls = [controls];
        }
        // TODO: parse newDN to determine if newSuperior should be specified
        const req = new messages_1.ModifyDNRequest({
            messageId: this._nextMessageId(),
            dn,
            deleteOldRdn: true,
            newRdn: newDN,
            controls,
        });
        const result = await this._send(req);
        if (result.status !== MessageResponseStatus_1.MessageResponseStatus.Success) {
            throw StatusCodeParser_1.StatusCodeParser.parse(result.status);
        }
    }
    /**
     * Performs an LDAP search against the server.
     *
     * @param {string} baseDN - The DN in the tree to start searching at
     * @param {SearchOptions} options
     * @param {Control|Control[]} [controls]
     */
    async search(baseDN, options = {}, controls) {
        if (!this.connected) {
            await this._connect();
        }
        if (controls) {
            if (Array.isArray(controls)) {
                // tslint:disable-next-line:no-parameter-reassignment
                controls = controls.slice(0);
            }
            else {
                // tslint:disable-next-line:no-parameter-reassignment
                controls = [controls];
            }
            // Make sure PagedResultsControl is not specified since it's handled internally
            for (const control of controls) {
                if (control instanceof PagedResultsControl_1.PagedResultsControl) {
                    throw new Error('Should not specify PagedResultsControl');
                }
            }
        }
        else {
            // tslint:disable-next-line:no-parameter-reassignment
            controls = [];
        }
        let pageSize = 100;
        if (typeof options.paged === 'object' && options.paged.pageSize) {
            pageSize = options.paged.pageSize;
        }
        else if (options.sizeLimit && options.sizeLimit > 1) {
            // According to the RFC, servers should ignore the paging control if
            // pageSize >= sizelimit.  Some might still send results, but it's safer
            // to stay under that figure when assigning a default value.
            pageSize = options.sizeLimit - 1;
        }
        const pagedResultsControl = new PagedResultsControl_1.PagedResultsControl({
            value: {
                size: pageSize,
            },
        });
        controls.push(pagedResultsControl);
        const searchRequest = new messages_1.SearchRequest({
            messageId: -1,
            baseDN,
            scope: options.scope,
            filter: options.filter,
            attributes: options.attributes,
            returnAttributeValues: options.returnAttributeValues,
            sizeLimit: options.sizeLimit,
            timeLimit: options.timeLimit,
            controls,
        });
        const searchResult = {
            searchEntries: [],
            searchReferences: [],
        };
        await this._sendSearch(searchRequest, searchResult, (typeof options.paged !== 'undefined') && options.paged !== false, pageSize, pagedResultsControl);
        return searchResult;
    }
    /**
     * Unbinds this client from the LDAP server.
     * @returns {void|Promise} void if not connected; otherwise returns a promise to the request to disconnect
     */
    async unbind() {
        if (!this.connected || !this.socket) {
            return;
        }
        const req = new messages_1.UnbindRequest({
            messageId: this._nextMessageId(),
        });
        await this._send(req);
    }
    async _sendSearch(searchRequest, searchResult, paged, pageSize, pagedResultsControl) {
        searchRequest.messageId = this._nextMessageId();
        const result = await this._send(searchRequest);
        if (result.status !== MessageResponseStatus_1.MessageResponseStatus.Success) {
            throw StatusCodeParser_1.StatusCodeParser.parse(result.status);
        }
        for (const searchEntry of result.searchEntries) {
            searchResult.searchEntries.push(searchEntry.toObject());
        }
        for (const searchReference of result.searchReferences) {
            searchResult.searchReferences.push(...searchReference.uris);
        }
        // Recursively search if paging is specified
        if (paged && (result.searchEntries.length || result.searchReferences.length)) {
            let pagedResultsFromResponse;
            for (const control of (result.controls || [])) {
                if (control instanceof PagedResultsControl_1.PagedResultsControl) {
                    pagedResultsFromResponse = control;
                    break;
                }
            }
            if (pagedResultsFromResponse && pagedResultsFromResponse.value && pagedResultsFromResponse.value.cookie && pagedResultsFromResponse.value.cookie.length) {
                // Recursively keep searching
                pagedResultsControl.value = pagedResultsControl.value || {
                    size: pageSize,
                };
                pagedResultsControl.value.cookie = pagedResultsFromResponse.value.cookie;
                await this._sendSearch(searchRequest, searchResult, paged, pageSize, pagedResultsControl);
            }
        }
    }
    _nextMessageId() {
        this.messageId += 1;
        if (this.messageId >= MAX_MESSAGE_ID) {
            this.messageId = 1;
        }
        return this.messageId;
    }
    /**
     * Open the socket connection
     * @returns {Promise<void>}
     * @private
     */
    _connect() {
        if (this.connected) {
            return true;
        }
        return new Promise((resolve, reject) => {
            if (this.secure) {
                this.socket = tls.connect(this.port, this.host, this.clientOptions.tlsOptions);
                this.socket.once('secureConnect', () => {
                    this._onConnect(resolve);
                });
            }
            else {
                this.socket = net.connect(this.port, this.host);
                this.socket.once('connect', () => {
                    this._onConnect(resolve);
                });
            }
            this.socket.once('error', (err) => {
                if (this.connectTimer) {
                    clearTimeout(this.connectTimer);
                    delete this.connectTimer;
                }
                reject(err);
            });
            if (this.clientOptions.connectTimeout) {
                this.connectTimer = setTimeout(() => {
                    if (this.socket && (!this.socket.readable || !this.socket.writable)) {
                        this.connected = false;
                        this.socket.destroy();
                        delete this.socket;
                    }
                    return reject(new Error('Connection timeout'));
                }, this.clientOptions.connectTimeout);
            }
        });
    }
    _onConnect(next) {
        clearTimeout(this.connectTimer);
        // Clear out event listeners from _connect()
        this.socket.removeAllListeners('error');
        this.socket.removeAllListeners('connect');
        this.socket.removeAllListeners('secureConnect');
        this.connected = true;
        // region Socket events handlers
        const socketError = (err) => {
            // Clean up any pending messages
            for (const [key, messageDetails] of Object.entries(this.messageDetailsByMessageId)) {
                if (messageDetails.message instanceof messages_1.UnbindRequest) {
                    // Consider unbind as success since the connection is closed.
                    messageDetails.resolve();
                }
                else {
                    messageDetails.reject(new Error(`Socket error. Message type: ${messageDetails.message.constructor.name} (0x${messageDetails.message.protocolOperation.toString(16)})\n${err.message || err.stack || 'Unknown'}`));
                }
                delete this.messageDetailsByMessageId[key];
            }
            this.socket.destroy();
        };
        const socketEnd = () => {
            if (this.socket) {
                // Acknowledge to other end of the connection that the connection is ended.
                this.socket.end();
            }
        };
        const socketTimeout = () => {
            if (this.socket) {
                this.socket.end();
            }
        };
        const socketData = (data) => {
            if (this.messageParser) {
                this.messageParser.read(data);
            }
        };
        const socketClose = () => {
            this.connected = false;
            if (this.socket) {
                this.socket.removeListener('error', socketError);
                this.socket.removeListener('close', socketClose);
                this.socket.removeListener('data', socketData);
                this.socket.removeListener('end', socketEnd);
                this.socket.removeListener('timeout', socketTimeout);
            }
            delete this.socket;
            // Clean up any pending messages
            for (const [key, messageDetails] of Object.entries(this.messageDetailsByMessageId)) {
                if (messageDetails.message instanceof messages_1.UnbindRequest) {
                    // Consider unbind as success since the connection is closed.
                    messageDetails.resolve();
                }
                else {
                    messageDetails.reject(new Error(`Connection closed before message response was received. Message type: ${messageDetails.message.constructor.name} (0x${messageDetails.message.protocolOperation.toString(16)})`));
                }
                delete this.messageDetailsByMessageId[key];
            }
            // Cleanup handlers
        };
        // endregion
        // Hook up event listeners
        this.socket.on('error', socketError);
        this.socket.on('close', socketClose);
        this.socket.on('data', socketData);
        this.socket.on('end', socketEnd);
        this.socket.on('timeout', socketTimeout);
        return next();
    }
    /**
     * Sends request message to the ldap server over the connected socket.
     * Each message request is given a unique id (messageId), used to identify the associated response when it is sent back over the socket.
     * @returns {Promise<Message>}
     * @private
     */
    _send(message) {
        if (!this.connected || !this.socket) {
            throw new Error('Socket connection not established');
        }
        /* tslint:disable:no-empty */
        let messageResolve = () => { };
        let messageReject = () => { };
        /* tslint:enable:no-empty */
        const sendPromise = new Promise((resolve, reject) => {
            // @ts-ignore
            messageResolve = resolve;
            messageReject = reject;
        });
        this.messageDetailsByMessageId[message.messageId.toString()] = {
            message,
            resolve: messageResolve,
            reject: messageReject,
            timeoutTimer: this.clientOptions.timeout ? setTimeout(() => {
                return messageReject(new Error(`${message.constructor.name}: Operation timed out`));
            }, this.clientOptions.timeout) : null,
        };
        // Send the message to the socket
        logDebug(`Sending message: ${message}`);
        this.socket.write(message.write(), () => {
            if (message instanceof messages_1.AbandonRequest) {
                logDebug(`Abandoned message: ${message.messageId}`);
                delete this.messageDetailsByMessageId[message.messageId.toString()];
                messageResolve();
            }
            else if (message instanceof messages_1.UnbindRequest) {
                logDebug(`Unbind success. Ending socket`);
                this.connected = false;
                if (this.socket) {
                    // Ignore any error since the connection is being closed
                    this.socket.removeAllListeners('error');
                    // tslint:disable-next-line:no-empty
                    this.socket.on('error', () => { });
                    this.socket.end();
                }
            }
            else {
                // NOTE: messageResolve will be called as 'data' events come from the socket
                logDebug('Message sent successfully.');
            }
        });
        return sendPromise;
    }
    _handleSendResponse(message) {
        const messageDetails = this.messageDetailsByMessageId[message.messageId.toString()];
        if (messageDetails) {
            // When performing a search, an arbitrary number of SearchEntry and SearchReference messages come through with the
            // same messageId as the SearchRequest. Finally, a SearchResponse will come through to complete the request.
            if (message instanceof messages_1.SearchEntry) {
                messageDetails.searchEntries = messageDetails.searchEntries || [];
                messageDetails.searchEntries.push(message);
            }
            else if (message instanceof messages_1.SearchReference) {
                messageDetails.searchReferences = messageDetails.searchReferences || [];
                messageDetails.searchReferences.push(message);
            }
            else if (message instanceof messages_1.SearchResponse) {
                // Assign any previously collected entries & references
                if (messageDetails.searchEntries) {
                    message.searchEntries.push(...messageDetails.searchEntries);
                }
                if (messageDetails.searchReferences) {
                    message.searchReferences.push(...messageDetails.searchReferences);
                }
                delete this.messageDetailsByMessageId[message.messageId.toString()];
                messageDetails.resolve(message);
            }
            else {
                delete this.messageDetailsByMessageId[message.messageId.toString()];
                messageDetails.resolve(message);
            }
        }
        else {
            logDebug(`Unable to find details related to message response: ${message}`);
        }
    }
}
exports.Client = Client;
//# sourceMappingURL=Client.js.map